# ADR 0001: PDF 변환 작업을 위한 메시지 큐(BullMQ) 도입

## 1. 배경 (Context)
초기 아키텍처에서는 클라이언트가 `/convert-url`을 호출하면 Express 메인 스레드 내에서 즉시 Puppeteer 브라우저를 띄워 PDF를 생성하고 반환했습니다. 하지만 PDF 렌더링은 대량의 CPU와 메모리를 소모하며 시간이 오래 걸리는 작업(10초 ~ 2분)입니다. 동시 요청이 발생할 경우 서버 타임아웃, 메모리 초과(OOM), 메인 이벤트 루프 블로킹 현상이 발생할 위험이 있었습니다.

## 2. 결정 사항 (Decision)
메인 HTTP 스레드에서 무거운 렌더링 작업을 분리하기 위해 **Redis 기반의 BullMQ를 메시지 큐 시스템으로 도입**하기로 결정했습니다.
- API 서버는 요청을 검증하고 Job만 생성한 뒤 클라이언트에게 202 응답을 보냅니다.
- 별도의 워커 프로세스(`worker.js`)가 큐에서 Job을 꺼내어 순차적(또는 제한된 동시성으로) 처리합니다.

## 3. 결과 및 영향 (Consequences)
**긍정적 영향:**
- API 서버의 응답성이 크게 향상되었으며 HTTP 타임아웃 문제를 원천적으로 해결했습니다.
- `pdfService.js`의 `MAX_CONCURRENCY` 및 Worker 설정을 통해 띄울 수 있는 최대 브라우저 인스턴스 수를 엄격하게 제어할 수 있어 서버 다운을 방지합니다.
- 실패한 작업에 대한 재시도(Retry) 로직 구현이 용이해졌습니다.

**부정적 영향 및 트레이드오프:**
- Redis라는 추가적인 인프라스트럭처 의존성이 생겼습니다.
- 클라이언트 측에서 완료 여부를 알기 위해 폴링(Polling)을 수행해야 하므로 프론트엔드 코드가 다소 복잡해졌습니다(향후 WebSocket이나 SSE로 개선 가능).